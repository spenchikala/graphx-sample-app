---------------------------------------------------------------------------------------------------------
//
// Reference:
// http://ampcamp.berkeley.edu/big-data-mini-course/graph-analytics-with-graphx.html
//
---------------------------------------------------------------------------------------------------------
//
//  Launch Spark Scala Shell:
//

c:
REM set JAVA_HOME=c:\dev\java\jdk1.7.0_51
set JAVA_HOME=c:\dev\java\jdk1.6.0_35
set PATH=%PATH%;%JAVA_HOME%\bin

set MAVEN_HOME=c:\dev\tools\apache-maven-3.0.4
set PATH=%PATH%;%MAVEN_HOME%\bin

set GIT_HOME=c:\dev\tools\Git
set PATH=%PATH%;%GIT_HOME%\bin

set SBT_HOME=c:\dev\tools\sbt\bin
set PATH=%PATH%;%SBT_HOME%\bin

set SCALA_HOME=C:\dev\languages\scala
set PATH=%PATH%;%SCALA_HOME%\bin

set SPARK_HOME=c:\dev\servers\spark-1.0.0
set PATH=%PATH%;%SPARK_HOME%\bin

set MAVEN_OPTS=-Xmx1024m -XX:MaxPermSize=512M -XX:ReservedCodeCacheSize=512m

cd c:\dev\projects\BigDataBootCampDallas2014\SparkWorkshop\SparkWorkshopLabs\graphx-sample-app

spark-shell.cmd


//
// Spark UI Web Console
//

http://localhost:4040

---------------------------------------------------------------------------------------------------------

//
// The Property Graph
//

import org.apache.spark.graphx._
import org.apache.spark.rdd.RDD

val vertexArray = Array(
	(1L, ("Alice", 28)),
	(2L, ("Bob", 27)),
	(3L, ("Charlie", 65)),
	(4L, ("David", 42)),
	(5L, ("Ed", 55)),
	(6L, ("Fran", 50))
)

val edgeArray = Array(
	Edge(2L, 1L, 7),
	Edge(2L, 4L, 2),
	Edge(3L, 2L, 4),
	Edge(3L, 6L, 3),
	Edge(4L, 1L, 1),
	Edge(5L, 2L, 2),
	Edge(5L, 3L, 8),
	Edge(5L, 6L, 3)
)

//
// Using sc.parallelize (introduced in the Spark tutorial) construct the following RDDs from the vertexArray and edgeArray variables.
//

val vertexRDD: RDD[(Long, (String, Int))] = sc.parallelize(vertexArray)

val edgeRDD: RDD[Edge[Int]] = sc.parallelize(edgeArray)

val graph: Graph[(String, Int), Int] = Graph(vertexRDD, edgeRDD)


// Graph Views

// Use graph.vertices to display the names of the users that are at least 30 years old. The output should contain (in addition to lots of log messages):

// Solution 1
graph.vertices.filter { case (id, (name, age)) => age > 30 }.collect.foreach {
	case (id, (name, age)) => println(s"$name is $age")
}

// Solution 2
graph.vertices.filter(v => v._2._2 > 30).collect.foreach(v => println(s"${v._2._1} is ${v._2._2}"))

// Solution 3
for ((id,(name,age)) <- graph.vertices.filter { case (id,(name,age)) => age > 30 }.collect) {
	println(s"$name is $age")
}


// Here we use the new String Interpolation feature in Scala 2.10:
val name = "Joey"
println(s"$name is ${ 3 * 10 }")


//
// Use the graph.triplets view to display who likes who.
//

for (triplet <- graph.triplets.collect) {
	println(s"${triplet.srcAttr._1} likes ${triplet.dstAttr._1}")
}

//
// If someone likes someone else more than 5 times than that relationship is getting pretty serious. For extra credit, find the lovers.
//

for (triplet <- graph.triplets.filter(t => t.attr > 5).collect) {
	println(s"${triplet.srcAttr._1} loves ${triplet.dstAttr._1}")
}


val inDegrees: VertexRDD[Int] = graph.inDegrees


// Define a class to more clearly model the user property
case class User(name: String, age: Int, inDeg: Int, outDeg: Int)

// Create a user Graph
val initialUserGraph: Graph[User, Int] = graph.mapVertices{ case (id, (name, age)) => User(name, age, 0, 0) }


// Fill in the degree information
val userGraph = initialUserGraph.outerJoinVertices(initialUserGraph.inDegrees) {
	case (id, u, inDegOpt) => User(u.name, u.age, inDegOpt.getOrElse(0), u.outDeg)
}.outerJoinVertices(initialUserGraph.outDegrees) {
	case (id, u, outDegOpt) => User(u.name, u.age, u.inDeg, outDegOpt.getOrElse(0))
}


//
// Using the degreeGraph print the number of people who like each user:
//

for ((id, property) <- userGraph.vertices.collect) {
	println(s"User $id is called ${property.name} and is liked by ${property.inDeg} people.")
}


//
// Print the names of the users who are liked by the same number of people they like.
//

userGraph.vertices.filter {
	case (id, u) => u.inDeg == u.outDeg
}.collect.foreach {
	case (id, property) => println(property.name)
}


// Find the oldest follower for each user
val oldestFollower: VertexRDD[(String, Int)] = userGraph.mapReduceTriplets[(String, Int)](
	// For each edge send a message to the destination vertex with the attribute of the source vertex
	edge => Iterator((edge.dstId, (edge.srcAttr.name, edge.srcAttr.age))),
  
  	// To combine messages take the message for the older follower
  	(a, b) => if (a._2 > b._2) a else b
)
//
// Display the oldest follower for each user:
//
userGraph.vertices.leftJoin(oldestFollower) { (id, user, optOldestFollower) =>
	optOldestFollower match {
    	case None => s"${user.name} does not have any followers."
    	case Some((name, age)) => s"${name} is the oldest follower of ${user.name}."
  	}
}.collect.foreach { case (id, str) => println(str) }



userGraph.vertices.leftJoin(oldestFollower) { (id, user, optOldestFollower) =>
  optOldestFollower match {
    case None => s"${user.name} does not have any followers."
    case Some((name, age)) => s"${name} is the oldest follower of ${user.name}."
  }
}.collect.foreach { case (id, str) => println(str) }


//
// As an exercise, try finding the average follower age of the followers of each user.
//

val averageAge: VertexRDD[Double] = userGraph.mapReduceTriplets[(Int, Double)](
	// map function returns a tuple of (1, Age)
	edge => Iterator((edge.dstId, (1, edge.srcAttr.age.toDouble))),
	// reduce function combines (sumOfFollowers, sumOfAge)
	(a, b) => ((a._1 + b._1), (a._2 + b._2))
).mapValues((id, p) => p._2 / p._1)


// Display the results
userGraph.vertices.leftJoin(averageAge) { (id, user, optAverageAge) =>
	optAverageAge match {
		case None => s"${user.name} does not have any followers."
		case Some(avgAge) => s"The average age of ${user.name}\'s followers is $avgAge."
	}
}.collect.foreach { case (id, str) => println(str) }


//
// Subgraph
//

val olderGraph = userGraph.subgraph(vpred = (id, user) => user.age >= 30)


// compute the connected components
val cc = olderGraph.connectedComponents

// display the component id of each user:
olderGraph.vertices.leftJoin(cc.vertices) {
	case (id, user, comp) => s"${user.name} is in component ${comp.get}"
}.collect.foreach{ case (id, str) => println(str) }





